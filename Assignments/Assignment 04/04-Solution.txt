# BRPD exercise 04
Anders Wind Steffensen

##Exercise 6.1
Results are indented with // 

1. Program
> fromString "let add x = let f y = x+y in f end in add 2 5 end";;
// val it : Absyn.expr =
//   Letfun
//     ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),
//      Call (Call (Var "add",CstI 2),CstI 5))
> run it;;
// val it : HigherFun.value = Int 7

2. Program
> fromString("let add x = let f y = x+y in f end in let addtwo = add 2 in addtwo 5 end end");;
// val it : Absyn.expr =
//   Letfun
//     ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),
//      Let ("addtwo",Call (Var "add",CstI 2),Call (Var "addtwo",CstI 5)))
> run it;;
// val it : HigherFun.value = Int 7

3. Program
> fromString("let add x = let f y = x+y in f end in let addtwo = add 2 in let x = 77 in addtwo 5 end end end");;
// val it : Absyn.expr =
//   Letfun
//     ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),
//      Let
//        ("addtwo",Call (Var "add",CstI 2),
//         Let ("x",CstI 77,Call (Var "addtwo",CstI 5))))
> run it;;
// val it : HigherFun.value = Int 7
The scope of x=77 is not in the same as "let add x = let f y = x+y in f end" therefore the result is 5+2

4. Program
> fromString("let add x = let f y = x+y in f end in add 2 end");;
// val it : Absyn.expr =
//   Letfun
//     ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),
//      Call (Var "add",CstI 2))
> run it;;
// val it : HigherFun.value =
//   Closure
//     ("f","y",Prim ("+",Var "x",Var "y"),
//      [("x", Int 2);
//       ("add",
//        Closure
//          ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),[]))])
This result in a closure. Since a closure is also a value (like int) this is possible. To evaluate to an Int value, one more parameter has to be parsed on, since right now one is missing: y.

##Exercise 6.2 and 6.3
I changed the following in HigherFun.fs

let rec eval (e : expr) (env : value env) : value =
    match e with
    | CstI i -> Int i
    | CstB b -> Int (if b then 1 else 0)
    | Var x  -> lookup env x
    | Prim(ope, e1, e2) -> 
      let v1 = eval e1 env
      let v2 = eval e2 env
      match (ope, v1, v2) with
      | ("*", Int i1, Int i2) -> Int (i1 * i2)
      | ("+", Int i1, Int i2) -> Int (i1 + i2)
      | ("-", Int i1, Int i2) -> Int (i1 - i2)
      | ("=", Int i1, Int i2) -> Int (if i1 = i2 then 1 else 0)
      | ("<", Int i1, Int i2) -> Int (if i1 < i2 then 1 else 0)
      |  _ -> failwith "unknown primitive or wrong type"
    | Let(x, eRhs, letBody) -> 
      let xVal = eval eRhs env
      let letEnv = (x, xVal) :: env 
      eval letBody letEnv
    | If(e1, e2, e3) -> 
      match eval e1 env with
      | Int 0 -> eval e3 env
      | Int _ -> eval e2 env
      | _     -> failwith "eval If"
    | Letfun(f, x, fBody, letBody) -> 
      let bodyEnv = (f, Closure(f, x, fBody, env)) :: env
      eval letBody bodyEnv
    | Fun(x, fBody) -> 
      Clos(x, fBody, env)
    | Call(eFun, eArg) -> 
      let fClosure = eval eFun env
      match fClosure with
      | Closure (f, x, fBody, fDeclEnv) ->
        let xVal = eval eArg env
        let fBodyEnv = (x, xVal) :: (f, fClosure) :: fDeclEnv
        in eval fBody fBodyEnv
      | Clos (x, fBody, fDeclEnv) ->
        let xVal = eval eArg env
        let fBodyEnv = (x, xVal) :: fDeclEnv
        in eval fBody fBodyEnv
      | _ -> failwith "eval Call: not a function";;


In Absyn.fs I changed the following

type expr = 
  | CstI of int
  | CstB of bool
  | Var of string
  | Let of string * expr * expr
  | Prim of string * expr * expr
  | If of expr * expr * expr
  | Letfun of string * string * expr * expr    (* (f, x, fBody, letBody) *)
  | Fun of string * expr
  | Call of expr * expr


In FunLex.fsl i changed the following

let keyword s =
    match s with
    | "else"  -> ELSE 
    | "end"   -> END
    | "false" -> CSTBOOL false
    | "if"    -> IF
    | "in"    -> IN
    | "let"   -> LET
    | "not"   -> NOT
    | "then"  -> THEN
    | "fun"   -> FUN
    | "true"  -> CSTBOOL true
    | _       -> NAME s
}

rule Token = parse
  | [' ' '\t' '\r'] { Token lexbuf }
  | '\n'            { lexbuf.EndPos <- lexbuf.EndPos.NextLine; Token lexbuf }
  | ['0'-'9']+      { CSTINT (System.Int32.Parse (lexemeAsString lexbuf)) }
  | ['a'-'z''A'-'Z']['a'-'z''A'-'Z''0'-'9']*
                    { keyword (lexemeAsString lexbuf) }
  | "(*"            { commentStart := lexbuf.StartPos;
                      commentDepth := 1; 
                      SkipComment lexbuf; Token lexbuf }
  | '='             { EQ }
  | "<>"            { NE }
  | '>'             { GT }
  | '<'             { LT }
  | ">="            { GE }
  | "<="            { LE }
  | '+'             { PLUS }                     
  | '-'             { MINUS }                     
  | '*'             { TIMES }                     
  | '/'             { DIV }                     
  | '%'             { MOD }
  | '('             { LPAR }
  | ')'             { RPAR }
  | eof             { EOF }
  | "->"            { ARROW }
  | _               { failwith "Lexer error: illegal symbol" }


In FunPar.fsy I changed the following

%token ELSE END FALSE IF IN LET NOT THEN TRUE FUN ARROW
%token PLUS MINUS TIMES DIV MOD
%token EQ NE GT LT GE LE
%token LPAR RPAR 
%token EOF

AtExpr:
    Const                               { $1                     }
  | NAME                                { Var $1                 }
  | LET NAME EQ Expr IN Expr END        { Let($2, $4, $6)        }
  | LET NAME NAME EQ Expr IN Expr END   { Letfun($2, $3, $5, $7) }
  | FUN NAME ARROW Expr					{ Fun($2, $4)            }
  | LPAR Expr RPAR                      { $2                     }
;


##Exercise 6.4


##Exercise 6.5

