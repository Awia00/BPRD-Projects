# BRPD exercise 04
Anders Wind Steffensen

##Exercise 6.1
Results are indented with // 

1. Program
> fromString "let add x = let f y = x+y in f end in add 2 5 end";;
// val it : Absyn.expr =
//   Letfun
//     ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),
//      Call (Call (Var "add",CstI 2),CstI 5))
> run it;;
// val it : HigherFun.value = Int 7

2. Program
> fromString("let add x = let f y = x+y in f end in let addtwo = add 2 in addtwo 5 end end");;
// val it : Absyn.expr =
//   Letfun
//     ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),
//      Let ("addtwo",Call (Var "add",CstI 2),Call (Var "addtwo",CstI 5)))
> run it;;
// val it : HigherFun.value = Int 7

3. Program
> fromString("let add x = let f y = x+y in f end in let addtwo = add 2 in let x = 77 in addtwo 5 end end end");;
// val it : Absyn.expr =
//   Letfun
//     ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),
//      Let
//        ("addtwo",Call (Var "add",CstI 2),
//         Let ("x",CstI 77,Call (Var "addtwo",CstI 5))))
> run it;;
// val it : HigherFun.value = Int 7
The scope of x=77 is not in the same as "let add x = let f y = x+y in f end" therefore the result is 5+2

4. Program
> fromString("let add x = let f y = x+y in f end in add 2 end");;
// val it : Absyn.expr =
//   Letfun
//     ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),
//      Call (Var "add",CstI 2))
> run it;;
// val it : HigherFun.value =
//   Closure
//     ("f","y",Prim ("+",Var "x",Var "y"),
//      [("x", Int 2);
//       ("add",
//        Closure
//          ("add","x",Letfun ("f","y",Prim ("+",Var "x",Var "y"),Var "f"),[]))])
This result in a closure. Since a closure is also a value (like int) this is possible. To evaluate to an Int value, one more parameter has to be parsed on, since right now one is missing: y.

##Exercise 6.2


##Exercise 6.3


##Exercise 6.4


##Exercise 6.5

